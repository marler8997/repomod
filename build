#!/usr/bin/env python3
import os
import sys
import subprocess
import zipfile
import shutil
from pathlib import Path


# === CONFIGURATION - EDIT THESE PATHS ===
GAME_DIR = r"C:\Program Files (x86)\Steam\steamapps\common\REPO"
GAME_MANAGED = os.path.join(GAME_DIR, "REPO_Data", "Managed")

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DOWNLOADS_DIR = os.path.join(SCRIPT_DIR, "downloads")

def main():
    bepinex_installed, bepinex_dll = install_bepinex()
    csc = find_csc()
    log(f"csc = '{csc}'")
    compile_mod(csc, bepinex_dll)

    log("copying game...")
    local_copy = os.path.join(SCRIPT_DIR, "REPO")
    shutil.rmtree(local_copy)
    shutil.copytree(GAME_DIR, local_copy)

    log("installing bepinx mod...")
    # shutil.copytree(bepinex_installed, local_copy)


def log(msg):
    print(f"build: {msg}", file=sys.stderr)

def find_csc():
    CSC_PATHS = [
        r"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe",
        r"C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe",
    ]

    for path in CSC_PATHS:
        if os.path.exists(path):
            return path

    # Try to find it in PATH
    try:
        result = subprocess.run(["where", "csc"], capture_output=True, text=True, check=True)
        return result.stdout.strip().split('\n')[0]
    except:
        pass

    log("ERROR: Could not find csc.exe")
    log("Searched paths:")
    for path in CSC_PATHS:
        log(f"  - {path}")
    sys.exit(1)

def fetch_extract_archive(url, out_dir, archive_format=None, archive_unique_name=None):
    archive_unique_name = archive_unique_name if archive_unique_name else os.path.basename(url)
    tuplebuild.log("installing '{}'...".format(archive_unique_name))
    tuplebuild.makedirs(DOWNLOADS_DIR)

    archive_file = os.path.join(DOWNLOADS_DIR, archive_unique_name)
    if not os.path.exists(archive_file):
        tuplebuild.download(url, archive_file)
    tuplebuild.makedirs(out_dir)
    tuplebuild.extract(archive_file, out_dir, archive_format)


def fetch(url, filename):
    basename = os.path.basename(filename)
    if os.path.exists(filename):
        log(f"download '{basename}': already done")
        return
    log(f"download '{basename}': executing...")
    makedirs(os.path.dirname(filename))
    tmp_filename = filename + ".downloading"
    remove(tmp_filename)
    run(None, ["curl", "--location", url, "--output", tmp_filename])
    os.rename(tmp_filename, filename)

def run(extra_env, *args, **kwargs):
    if not 'check' in kwargs:
        kwargs['check'] = True

    cmd_prefix = ''
    cmd_suffix = ''

    cd_prefix = ''
    if 'cwd' in kwargs:
        if IS_WINDOWS:
            cmd_prefix = 'cmd /c "'
            cmd_suffix = '"'
        else:
            cmd_prefix = '('
            cmd_suffix = ')'
        # TODO: should we use & or &&?
        cd_prefix = f"cd {kwargs['cwd']} && "

    env_prefix = ''
    if extra_env:
        kwargs['env'] = {**os.environ, **extra_env}
        if IS_WINDOWS:
            cmd_prefix = 'cmd /c "'
            cmd_suffix = '"'
            for e in extra_env:
                env_prefix += f"set {e}={extra_env[e]} && "
        else:
            for e in extra_env:
                env_prefix += f"{e}={extra_env[e]} "
    log("[RUN] "
        + cmd_prefix + cd_prefix + env_prefix
        + subprocess.list2cmdline(*args)
        + cmd_suffix)
    sys.stdout.flush()
    return subprocess.run(*args, **kwargs)

def makedirs(path):
    if not os.path.exists(path):
        os.makedirs(path)
def remove(path):
    try:
        os.remove(path)
    except FileNotFoundError:
        pass

def install_bepinex():
    BEPINEX_VERSION = "5.4.23.4"
    stem = f"BepInEx_win_x64_{BEPINEX_VERSION}"
    installed = os.path.join(SCRIPT_DIR, "dep", stem)
    dll = os.path.join(installed, "BepInEx", "core", "BepInEx.dll")
    if not os.path.exists(installed):
        url = f"https://github.com/BepInEx/BepInEx/releases/download/v{BEPINEX_VERSION}/{stem}.zip"
        archive = os.path.join(DOWNLOADS_DIR, os.path.basename(url))
        fetch(url, archive)
        log(f"unzipping '{archive}'")
        extracting = installed + ".extracting"
        try:
            with zipfile.ZipFile(archive, 'r') as zip_ref:
                zip_ref.extractall(extracting)
        except Exception as e:
            log(f"ERROR: Failed to extract BepInEx: {e}")
            sys.exit(1)
        os.rename(extracting, installed)
    if not os.path.exists(dll):
        sys.exit(f"the archive has been installed too '{installed}' but it's missing the dll '{dll}'")
        sys.exit(1)
    return (installed, dll)


def compile_mod(csc, bepinex_dll):
    unity_core_dll = os.path.join(GAME_MANAGED, "UnityEngine.CoreModule.dll")
    unity_dll = os.path.join(GAME_MANAGED, "UnityEngine.dll")
    netstandard_dll = os.path.join(GAME_MANAGED, "netstandard.dll")  # Add this
    if not os.path.exists(unity_core_dll):
        sys.exit(f"WARNING: Unity CoreModule DLL not found at {unity_core_dll}")
    if not os.path.exists(unity_dll):
        sys.exit(f"WARNING: Unity DLL not found at {unity_dll}")
    if not os.path.exists(netstandard_dll):
        sys.exit(f"WARNING: netstandard DLL not found at {netstandard_dll}")
    cmd = [
        csc,
        "/target:library",
        "/out:MarlerMod.dll",
        f"/reference:{bepinex_dll}",
        f"/reference:{unity_dll}",
        f"/reference:{unity_core_dll}",
        f"/reference:{netstandard_dll}",  # Add this reference
        "MarlerMod.cs"
    ]
    log(subprocess.list2cmdline(cmd))
    subprocess.run(cmd, check=True)

def copy_to_game(bepinex_installed):
    """Optionally copy mod to game plugins folder"""
    plugins_dir = os.path.join(GAME_DIR, "BepInEx", "plugins")

    if not os.path.exists(plugins_dir):
        log("BepInEx plugins folder not found in game directory.")
        log("Please install BepInEx to your game first:")
        log(f"  1. Copy {bepinex_installed} to: {GAME_DIR}")
        log(f"  2. Run the game once to initialize BepInEx")
        log(f"  3. Copy MarlerMod.dll to: {plugins_dir}")
        return

    log(f"BepInEx plugins folder detected!")
    response = input("Copy mod to game now? (y/n): ").lower().strip()

    if response == 'y':
        import shutil
        dest = os.path.join(plugins_dir, "MarlerMod.dll")
        shutil.copy2("MarlerMod.dll", dest)
        log(f"Mod copied to: {dest}")
        log("Launch the game to test!")
    else:
        log(f"Manual copy: copy MarlerMod.dll to {plugins_dir}")

if __name__ == "__main__":
    main()
